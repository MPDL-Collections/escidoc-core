<?xml version="1.0" encoding="UTF-8"?><SDODE LA="D"><DP N="1"/><P ID="0001" ALIGN="LEFT"> xmlfulltext 简体中文网页 Die Erfindung bezieht sich auf ein Verfahren und ein System zur Verwaltung von <BR/>Beziehungen zwischen Objekten in komponentenbasierten Softwaresystemen. </P><P ID="0002" ALIGN="LEFT">Komponenten werden in zunehmendem Maße als Bausteine von Softwaresystemen <BR/>eingesetzt. Sie zeichnen sich durch folgende Eigenschaften aus: <UL ST="•"><LI>Eine Softwarekomponente besitzt wohldefinierte öffentliche Schnittstellen, über <BR/>die eine Anwendung oder andere Komponenten auf ihre Dienste zugreifen <BR/>können. Im Allgemeinen werden zwei Schnittstellen unterschieden: die Verwaltungsschnittstelle <BR/>und die Exemplarschnittstelle. Über die Verwaltungsschnittstelle <BR/>werden Exemplare der Komponente erzeugt und gesucht. Über die <BR/>Exemplarschnittstelle wird auf die Dienste eines konkreten Exemplars <BR/>zugegriffen. </LI><LI>Die Realisierung/Implementierung einer Komponente wird vor dem Benutzer <BR/>einer Komponente verborgen. Man bezeichnet diese Eigenschaft auch als <BR/>Kapselung. Damit unterstützen Softwarekomponenten die Modularisierung von <BR/>Software-Systemen als Voraussetzung für deren evolutionäre Weiterentwicklung <BR/>und deren Zusammenbau auf der Basis von selbst entwickelten und zugekauften <BR/>Bausteinen. </LI></UL></P><P ID="0003" ALIGN="LEFT">Ein Komponententyp ist die konkrete Realisierung eines Softwaremoduls als Vorlage <BR/>für eine Menge von Entitäten in der Problemdomäne, z.B. alle Kunden in einer <DP N="2"/></P><P ID="0004" ALIGN="LEFT">Anwendungsdomäne. Er definiert die Struktur und das Verhalten der Entitäten. Die <BR/>Entitäten werden im Softwaresystem durch sogenannte Exemplare des <BR/>Komponententyps repräsentiert. </P><P ID="0005" ALIGN="LEFT">Fig. 1 zeigt das Verhältnis zwischen Komponententyp und Exemplaren. Der <BR/>Komponententyp Kunde K1 definiert die prinzipielle Struktur und das Verhalten von <BR/>Kundenentitäten. Sie besitzt prinzipiell ein Attribut &quot;Name&quot;. Die einzelnen Exemplare <BR/>E1-E5 besitzen konkrete Werte für die verschiedenen Attribute der Struktur und eine <BR/>Identität. Z.B. hat Exemplar E1 den Namen &quot;Meier&quot;. </P><P ID="0006" ALIGN="LEFT">Es werden im Allgemeinen zwei Arten von Komponenten unterschieden, kurzlebige, <BR/>transiente und langlebige, persistente Komponenten. Transiente Komponenten <BR/>übernehmen zumeist Hilfsfunktionen innerhalb eines Softwaresystems und können <BR/>die Kommunikation zwischen Subsystemen optimieren. Persistente Komponenten <BR/>repräsentieren Entitäten des Geschäftsbereiches, der mit Hilfe des Software-Systems <BR/>unterstützt werden soll, z.B. ein Kunde oder ein Konto. Solche <BR/>Komponenten sind über die Lebenszeit eines Serverprozesses hinaus eindeutig <BR/>identifizierbar, ihr Zustand wird in einem Datenbankmanagementsystem gespeichert. <BR/>Der Fokus wird im weiteren auf persistenten Komponenten liegen. </P><P ID="0007" ALIGN="LEFT">In vielen bekannten Fällen kommen verteilte Komponententechnologien zum Einsatz. <BR/>Sie zeichnen sich dadurch aus, dass Komponenten auf verschiedenen Rechnern <BR/>eines Rechnersystems betrieben werden können und für die Anwendung trotzdem <BR/>die Illusion eines zentralen Systems erzeugt wird. Dadurch können zentrale <BR/>Ressourcen effizient genutzt werden und es ergeben sich völlig neue Dimensionen <BR/>hinsichtlich der Skalierbarkeit eines Softwaresystems. Die bekanntesten <BR/>Komponententechnologien sind <UL ST="•"><LI>COM (Roger Sessions, &quot;COM and DCOM - Microsoft's Vision for Distributed <BR/>Objects&quot;, Wiley &amp; Sons Inc., 1998, ISBN 0-471-19381-X), </LI><LI>.NET (David S. Platt, &quot;Introducing Microsoft® .NET&quot;, Microsoft Press, 2001, 0-7356-1377-X), <DP N="3"/></LI><LI>Enterprise JavaBeans (Ed Roman, &quot;Mastering Enterprise Java Beans and the <BR/>Java 2 Platform, Enterprise Edition&quot;, Wiley &amp; Sons Inc., 1999, ISBN 0-471-33229-1) <BR/>und </LI><LI>CORBAcomponents. </LI></UL></P><P ID="0008" ALIGN="LEFT">Verteilte Komponenten werden in sogenannten Applikationsservern betrieben, wobei <BR/>der Applikationsserver verschiedene sogenannte Container enthalten kann, die als <BR/>eigentliche Ablaufumgebung der Komponenten fungieren. Der Applikationsserver <BR/>verfügt über einen oder mehrere sogenannte Container, die aus einem oder <BR/>mehreren Betriebssystemprozessen bestehen. Der Container stellt verschiedene <BR/>Dienste für den Betrieb von Komponenten bereit, z.B. Sicherheit, Lifecycle-Management, <BR/>Transaktionsmanagement und Persistenz. Ein Komponententyp wird <BR/>in einem oder mehreren Containern installiert. Eine solche Komponenteninstallation <BR/>wird im weiteren als Komponente bezeichnet. Komponenten eines Typs <BR/>unterscheiden sich durch verschiedene Konfigurationen (z.B. bezüglich der <BR/>verwendeten Datenbankinstanz) und unterschiedliche symbolische Namen. Ein <BR/>Client bindet unter Verwendung des symbolischen Namens an die <BR/>Verwaltungsschnittstelle einer Komponente und erzeugt oder sucht konkrete <BR/>Exemplare der Komponente. Von jeder Komponente kann es ein oder mehrere <BR/>Exemplare geben. Deren persistenter Zustand wird in einem <BR/>Datenbankmanagementsystem gespeichert. Der Container ist für das Lifycycle-Management <BR/>der Komponentenexemplare zuständig. Wenn ein Client auf ein <BR/>Exemplar zugreifen möchte, erzeugt der Container eine transiente Repräsentation <BR/>des Komponentenexemplars und lädt die Daten des in der Datenbank gespeicherten <BR/>persistenten Exemplars in diese Laufzeitrepräsentation. Nach Beendigung der <BR/>Benutzung wird der Zustand des Exemplares in der Datenbank gespeichert und die <BR/>Laufzeitinstanz freigegeben. Der Zugriff auf die Exemplare einer Komponente erfolgt <BR/>mit Hilfe von sogenannten Referenzen, die der Applikationsserver erzeugt. </P><P ID="0009" ALIGN="LEFT">Fig. 2 zeigt den beispielhaften Aufbau eines Applikationsservers AS1. Der <BR/>Applikationsserver AS1 enthält einen Container CT1, in dem eine Komponente K2 <BR/>des Komponententyps Kunde installiert ist. PE1 ist ein Exemplar der Komponente <BR/>Kunde, dessen Zustand in der Datenbank DB1 abgespeichert wird. Der Client C1 <DP N="4"/> <BR/>möchte auf dieses Exemplar zugreifen. Dazu muß zunächst auf die <BR/>Verwaltungsschnittstelle VS1 zugegriffen werden. Dazu benötigt der Client C1 eine <BR/>Referenz auf diese Schnittstelle. Der Client kennt den symbolischen Namen der <BR/>Verwaltungschnittstelle der Komponente K2 innerhalb der <BR/>Applikationsserverumgebung. Der Client benutzt einen Dienst des <BR/>Applikationsservers, der einen symbolischen Namen in eine solche Referenz <BR/>umwandeln kann, um eine transiente Referenz auf die Verwaltungsschnittstelle VS1 <BR/>zu erlangen. Diesen Vorgang bezeichnet man als Binden des Clients an eine <BR/>Komponente. Wenn der Client C1 in Besitz einer gültigen Referenz auf die <BR/>Verwaltungsschnittstelle VS1 ist, ruft er auf dieser Schnittstelle eine Suchmethode <BR/>auf, die den Kunden anhand seines Namens sucht. Dabei handelt es sich im Beispiel <BR/>um das Exemplar PE1. Nachdem das Exemplar gefunden wurde, erzeugt der <BR/>Container die Laufzeitrepräsentation E6 des Komponententyps Kunde und lädt die <BR/>Daten des Exemplars PE1 in die Laufzeitrepräsentation E6. Als Ergebnis erhält der <BR/>Client eine Referenz auf die Laufzeitinstanz E6, die er benutzt, um Operationen auf <BR/>der Laufzeitrepräsentation E6 auszuführen. Wenn die Laufzeitrepräsentation nicht <BR/>mehr benötigt wird, wird der Zustand wieder in der Datenbank DB1 gespeichert. </P><P ID="0010" ALIGN="LEFT">In jeder Problemdomäne sind die verschiedenen Entitäten miteinander vernetzt. <BR/>Softwarekomponenten sind Repräsentanten solcher Entitäten und müssen deshalb <BR/>ebenfalls miteinander Beziehungen eingehen können. Z.B. steht ein Kunde in einer <BR/>Bankanwendung mit seinen Konten in einer Beziehung. Das ermöglicht es einem <BR/>Client, über die Verwaltungsschnittstelle der Komponente Kunde ein <BR/>Kundenexemplar, unter Verwendung von dessen Kundennummer, suchen zu lassen <BR/>und, von diesem Kundenexemplar ausgehend, auf die mit dem Kunden in Beziehung <BR/>stehenden Konten-Exemplare zuzugreifen. Durch Beziehungen werden <BR/>Objektgeflechte in einem Softwaresystem aufgebaut, die der Navigation durch das <BR/>Softwaresystem dienen. </P><P ID="0011" ALIGN="LEFT">Beziehungen sind gerichtet, sie können entweder nur in einer Richtung oder in beide <BR/>Richtungen zwischen den beteiligten Komponenten navigiert werden. Erstere <BR/>bezeichnet man als unidirektionale Beziehungen, letztere als bidirektionale <BR/>Beziehungen. Bidirektionale Beziehungen können prinzipiell aus zwei <BR/>unidirektionalen Beziehungen zusammengesetzt werden. Deshalb wird im Folgenden <DP N="5"/> <BR/>eine Beziehung ausschließlich als gerichtete Referenz von einer Komponente zu <BR/>einer anderen Komponente betrachtet. </P><P ID="0012" ALIGN="LEFT">Beziehungen können anhand der Anzahl der referenzierbaren Exemplare klassifiziert <BR/>werden. Diese Eigenschaft wird als Kardinalität einer Beziehung bezeichnet. Hier <BR/>werden zwei Arten unterschieden: Wenn maximal ein Exemplar referenziert werden <BR/>kann, spricht man von der Kardinalität 1, wenn mehrere Exemplare referenziert <BR/>werden können, ist die Kardinalität n. </P><P ID="0013" ALIGN="LEFT">Die meisten komponentenorientierten Systeme werden unter Zuhilfenahme der <BR/>Objekttechnologie realisiert. Die Objekttechnologie ist unter anderem dadurch <BR/>gekennzeichnet, dass das Prinzip der Vererbung als Mittel der Abstraktion eingesetzt <BR/>wird. Die Vererbung ist eine Beziehung zwischen Typen. Es werden gemeinsame <BR/>Eigenschaften verschiedener Typen zu einem sogenannten Basistyp <BR/>zusammengefaßt und diese Typen stehen dann in einer Vererbungsbeziehung zu <BR/>ihrem Basistyp. Die Vererbung bietet viele Vorteile für die Modularisierung von <BR/>Softwaresystemen. Zum einen kann eine Anwendung auf der Ebene des Basistyps <BR/>mit den Exemplaren aller abgeleiteten Typen kommunizieren. Sie muß diese Typen <BR/>nicht einmal kennen. Zum anderen können gemeinsame Funktionen und <BR/>Eigenschaften auf der Ebene des Basistyps realisiert und dann von den abgeleiteten <BR/>Typen über die Beziehung zu ihrem Basistyp geerbt werden. </P><P ID="0014" ALIGN="LEFT">Angesichts des Stellenwerts der Vererbung bei der Realisierung moderner <BR/>Softwaresysteme ist es unverzichtbar, dass ein Komponentensystem Beziehungen <BR/>zwischen den Exemplaren von Komponententypen in Kombination mit Vererbung <BR/>unterstützt. </P><P ID="0015" ALIGN="LEFT">Eine Übersicht über Beziehungen und deren Verwendung bei der Entwicklung <BR/>objektorientierter und komponentenorientierter Softwaresysteme geben Martin <BR/>Fowler und Kendall Scott in &quot;UML Distilled&quot;, Addison-Wesley, 1997, ISBN 0-201-32563-2. </P><P ID="0016" ALIGN="LEFT">Die oben beschriebenen Referenzen auf Komponenten, die ein Applikationsserver <BR/>für den Zugriff von einem Client auf ein Komponenten-Exemplar bereitstellt, eignen <BR/>sich nicht für die langlebige Speicherung von Beziehungen zwischen <DP N="6"/> <BR/>Softwarekomponenten, da sie im Allgemeinen kurzzeitig gültige Informationen über <BR/>die Lokation eines Komponentenexemplars, wie z.B. die TCP/IP-Portnummer des <BR/>Applikationsserverprozesses, in dem die Komponente sich zum aktuellen Zeitpunkt <BR/>befindet, enthalten. Diese Lokation kann sich bei jedem Aktivierungszyklus ändern. </P><P ID="0017" ALIGN="LEFT">Es sind unterschiedliche Lösungsansätze zur Realisierung langlebiger Beziehungen <BR/>in einem komponentenbasierten Softwaresystem bekannt. Einige davon werden von <BR/>Grant Holland in &quot;Entity Bean relationsships in EJB 1.1, Part 1: The basic technique&quot;, <BR/>Java Report, Vol. 6, No 4., April 2001, Seiten 72ff und &quot;Entity Bean relationsships in <BR/>EJB 1.1, Part 1: Robust and practical techniques&quot;, Java Report, Vol. 6, No 6., Juni <BR/>2001, Seiten 58ff beschrieben. Folgende Entwicklungsrichtungen zeichnen sich ab: </P><P ID="0018" ALIGN="LEFT">Hersteller von Werkzeugen zum Object-to-Relational-Mapping, wie z.B. WebGain mit <BR/>dem Werkzeug TopLink for Java, erweitern ihr Werkzeuge für die Unterstützung von <BR/>Softwarekomponenten. Dazu werden zusätzliche Mappinginformationen und <BR/>Hilfsschnittstellen in die Komponenten eingefügt, um die Beziehungen abspeichern <BR/>und die Exemplare beim Navigieren der Beziehung wieder aktivieren zu können. <BR/>Diese Werkzeuge unterstützen neben bloßen Beziehungen zwischen zwei Typen <BR/>von Komponenten im Allgemeinen auch Beziehungen zwischen <BR/>Vererbungshierarchien von Komponenten. Diese Unterstützung wird aber zumeist <BR/>mit einer Verletzung der Kapselung von Komponenten, nämlich durch den direkten <BR/>Durchgriff auf die Implementierung und das Datenbankschema der referenzierten <BR/>Komponente, und mit Einschränkungen hinsichtlich der physischen Verteilbarkeit der <BR/>Komponenten erkauft. </P><P ID="0019" ALIGN="LEFT">Darüber hinaus ist zu berücksichtigen, dass es sich bei solchen Produkten in der <BR/>Regel um Zusatzprodukte zu Applikationsservern handelt. Dadurch entstehen <BR/>zusätzliche Kosten für die Anschaffung und den Betrieb des Softwaresystems. <BR/>Außerdem kann es in verstärktem Maße zu Kompatibilitätsproblemen zwischen den <BR/>verschiedenen eingesetzten Produkten kommen. Für jede neue Version des <BR/>Applikationsservers muß vom Hersteller des Zusatzproduktes eine passende Version <BR/>seines Werkzeuges bereitgestellt werden, dadurch kann sich der Projektfortgang <BR/>verzögern. <DP N="7"/></P><P ID="0020" ALIGN="LEFT">Einige Hersteller von Applikationsservern, wie Borland mit dem AppServer oder IBM <BR/>mit dem Websphere Application Server in Kombination mit IBM Visual Age for Java, <BR/>unterstützen die Realisierung von Beziehungen zwischen Komponenten, ohne die <BR/>Kapselung der Komponenten zu verletzen. Dabei wird der referenzierenden <BR/>Komponente in ihren Konfigurationsinformationen die Information mitgegeben, <BR/>welche Komponente sie in einer konkreten Installation referenzieren kann. Es wird <BR/>entweder der persistente Identifikator des referenzierten Komponentenexemplars im <BR/>persistenten Zustand des referenzierenden Komponentenexemplars (a) oder der <BR/>persistente Identifikator des referenzierenden Komponentenexemplars im <BR/>persistenten Zustand des referenzierten Komponentenexemplars (b) gespeichert. <BR/>Diese Muster sind Adaptionen gängiger Konzepte für die Realisierung von <BR/>Beziehungen im Kontext relationaler Datenbankmanagementsystem an die <BR/>Verwendung in Komponentensystemen. Die Auflösung der Beziehung erfolgt über <BR/>die Verwaltungsschnittstelle der referenzierten Komponente. Zu dieser <BR/>Verwaltungsschnittstelle wird unter Verwendung der oben beschriebenen <BR/>Konfigurationsinformationen gebunden. Im Fall (a) wird dort eine Suchfunktion <BR/>aufgerufen, die den persistenten Identifikator des gesuchten Komponentenexemplars <BR/>als Parameter erhält und eine transiente Referenz auf das entsprechende Exemplar <BR/>zurückgibt. Im Fall (b) wird die Suchfunktion mit dem persistenten Identifikator des <BR/>referenzierenden Komponentenexemplars aufgerufen und sucht anhand dieses <BR/>Identifikators die passende(n) Exemplar(e), die diesen Identifkator in ihrem <BR/>persistenten Zustand gespeichert haben. Für dieses/diese Exemplar(e) werden <BR/>entsprechende transiente Referenzen an den Aufrufer zurückgeliefert. </P><P ID="0021" ALIGN="LEFT">Diese Lösung hat den Vorteil, dass sie die technischen Eigenschaften einer <BR/>Komponente, wie die Verteilbarkeit und die Kapselung, nicht einschränkt. Es werden <BR/>aber keine Beziehungen zwischen Vererbungshierarchien von Komponenten <BR/>unterstützt. </P><P ID="0022" ALIGN="LEFT">Damit besteht das Problem, dass keiner der derzeit existierenden Ansätze <BR/>Beziehungen in Kombination mit Vererbung zwischen Komponenten unterstützt, <BR/>ohne dabei negative Auswirkungen auf die Verteilbarkeit und Kapselung einer <BR/>Komponente zu haben. <DP N="8"/></P><P ID="0023" ALIGN="LEFT">Der Erfindung liegt deshalb die Aufgabe zugrunde, eine Lösung für die Realisierung <BR/>von persistenten Beziehungen zwischen Softwarekomponenten anzugeben, die die <BR/>vorteilhaften Eigenschaften von Komponentensystemen nicht einschränkt, und <BR/>gleichzeitig die Möglichkeit bietet, Beziehungen zwischen Vererbungshierarchien von <BR/>Softwarekomponenten zu realisieren. </P><P ID="0024" ALIGN="LEFT">Diese Aufgabe wird durch ein Verfahren zur Verwaltung von Beziehungen zwischen <BR/>Objekten in komponentenbasierten Softwaresystemen gelöst, dass die in Anspruch 1 <BR/>oder 2 angegebenen Merkmale aufweist. Vorteilhafte Ausgestaltungen und Systeme <BR/>zur Durchführung des Verfahrens sind in weiteren Ansprüchen angegeben. </P><P ID="0025" ALIGN="LEFT">Die erfindungsgemäßen Lösungen sind Weiterentwicklungen des oben als zweites <BR/>beschriebenen Ansatzes. Zur persistenten Speicherung einer Beziehung werden wie <BR/>dort die persistenten Identifikatoren von Komponenten verwendet. Dabei gibt es wie <BR/>beschrieben zwei Varianten der Speicherung: </P><P ID="0026" ALIGN="LEFT">Zum einen ist es möglich, den oder die Identifikatoren der referenzierten <BR/>Komponenten-Exemplare im persistenten Zustand des referenzierenden <BR/>Komponenten-Exemplars zu speichern. Diesen Weg geht man im Allgemeinen bei <BR/>der Realisierung von Beziehungen der Kardinalität 1. </P><P ID="0027" ALIGN="LEFT">Die Alternative besteht darin, den Identifikator des referenzierenden Komponenten-Exemplars <BR/>im referenzierten Komponenten-Exemplar zu speichern. Dieses Muster <BR/>wird im Allgemeinen verwendet, wenn die Beziehung auf mehr als ein Komponenten-Exemplar <BR/>verweisen kann (Kardinalität n). </P><P ID="0028" ALIGN="LEFT">Wenn auf die referenzierten Exemplare wieder zugegriffen werden soll, ist es <BR/>notwendig, den oder die Fremdschlüssel in transiente Referenzen auf die <BR/>referenzierten Komponentenexemplare umzuwandeln, die ein Client für den Zugriff <BR/>auf die Komponenten verwenden kann. Für die Umwandlung werden die <BR/>Verwaltungsschnittstellen der Komponenten verwendet, die am referenzierten Ende <BR/>der Beziehung teilnehmen können. Im persistenten Zustand eines Exemplars werden <BR/>zwar die Fremdschlüssel der referenzierten Exemplare gespeichert, aber nicht <BR/>notwendigerweise die dazugehörigen Komponenten. Jedoch ist nur die Komponente, <BR/>die ein konkretes Exemplar verwaltet, bzw. ihre Verwaltungsschnittstelle, in der Lage, <DP N="9"/> <BR/>Laufzeitreprepräsentationen der Komponentenexemplare und Referenzen auf diese <BR/>Exemplare zu erzeugen. </P><P ID="0029" ALIGN="LEFT">Deshalb werden für jede Beziehung bei der referenzierenden Komponente (und <BR/>damit gültig für alle Exemplare der referenzierenden Komponente) Informationen <BR/>über alle Komponenten abgelegt, deren Exemplare durch die Beziehung referenziert <BR/>werden können. </P><P ID="0030" ALIGN="LEFT">Der prinzipielle Aufbau einer solchen Struktur wird in Fig. 3 illustriert. Die <BR/>Komponente K3 verfügt über Konfigurationsinformationen KI1, in denen symbolische <BR/>Referenzen auf die Komponenten K4 und K5 abgelegt sind. Damit können <BR/>Exemplare dieser Komponenten mit den Exemplaren der Komponente K3 in <BR/>Beziehung gesetzt werden. Die Anzahl der referenzierbaren Komponenten ist nicht <BR/>limitiert. Die abgelegte Information ist so beschaffen, dass die referenzierende <BR/>Komponente unter Nutzung von Mechanismen des Applikationsservers zu den <BR/>Verwaltungsschnittstellen der referenzierten Komponenten binden kann. </P><P ID="0031" ALIGN="LEFT">Um die Beziehung zu traversieren, bindet das referenzierende Komponenten-Exemplar <BR/>zunächst zu den Verwaltungsschnitsttellen der referenzierten <BR/>Komponenten. Danach werden die gespeicherten Fremdschlüssel verwendet, um die <BR/>konkreten referenzierten Komponenten-Exemplare mit Hilfe von Suchmethoden der <BR/>Verwaltungsschnittstellen zu finden. Als Ergebnis des Aufrufes einer Suchmethode <BR/>erhält die referenzierende Komponte im Erfolgsfall eine oder mehrere transiente <BR/>Referenzen auf die gesuchten Komponentenexemplare. Der konkrete Algorithmus <BR/>der Suche gestaltet sich in Abhängigkeit von der Kardinalität der Beziehung <BR/>unterschiedlich: <UL ST="•"><LI>Bei der Kardinalität 1 werden die Suchmethoden der verschiedenen <BR/>Komponenten parallel oder sequentiell aufgerufen und der erste Treffer als <BR/>Ergebnis verwendet. </LI><LI>Bei der Kardinalität n werden die Suchergebnisse der verschiedenen <BR/>Komponenten zu einem Gesamtergnis zusammengefaßt. </LI></UL><DP N="10"/></P><P ID="0032" ALIGN="LEFT">Als Parameter der Suche werden entweder der (die) gespeicherte(n) Fremdschlüssel <BR/>der referenzierten Komponentenexemplare oder der Identifikator des <BR/>referenzierenden Komponentenexemplares verwendet. </P><P ID="0033" ALIGN="LEFT">Weitere vorteilhafte Eigenschaften der Erfindung neben der Unterstützung von <BR/>Beziehungen zwischen Vererbungshierachien sind: <UL ST="•"><LI>Es ist möglich, Komponenten eines Komponententyps, die in verschiedenen <BR/>Containern eines Applikationsservers installiert sind, in eine Beziehung <BR/>einzubeziehen. </LI><LI>Die Realisierung der Erfindung kann ausschließlich mit den Mitteln des <BR/>Applikationsservers erfolgen und ist nicht an die Verwendung von zusätzlichen <BR/>Produkten gebunden. </LI></UL></P><P ID="0034" ALIGN="LEFT">Eine weitere Beschreibung der Erfindung wird im folgenden Beispiel gegeben. </P><P ID="0035" ALIGN="LEFT">Es werden dazu folgende Figuren verwendet: <UL ST="•"><LI>Fig. 4 zeigt eine Übersicht über die verwendeten Komponententypen in Form <BR/>eines Klassendiagrammes in der Notation der Unified Modeling Language (UML). </LI><LI>Die verschiedenen Abläufe während der Arbeit mit Beziehungen werden durch <BR/>Fig. 6 bis Fig. 9 in Form von Sequenz-Diagrammen in der Notation der UML <BR/>illustriert. </LI></UL></P><P ID="0036" ALIGN="LEFT">Die Problemdomäne wird in Fig. 4 dargestellt. Es handelt sich dabei um eine <BR/>einfache Anwendung zur Verwaltung von Kunden und deren Konten. Zwischen dem <BR/>Komponententyp <I>Kunde</I> und dem Komponententyp <I>Konto</I> existiert eine bidirektionale <BR/>Beziehung. In der technischen Realisierung werden daraus zwei unidirektionale <BR/>Beziehungen im Sinne der Erfindung, die sich durch folgende Aspekte <BR/>unterscheiden: </P><P ID="0037" ALIGN="LEFT">Die Beziehung vom Konto zum Kunden hat die Kardinalität 1 und der Identifikator <BR/>des jeweils referenzierten Kunden wird im Konto gespeichert. <DP N="11"/></P><P ID="0038" ALIGN="LEFT">Die Beziehung vom Kunden zu seinen Konten hat die Kardinalität n. Für diese <BR/>Richtung der Beziehung ist kein zusätzlicher Speicherplatz erforderlich. Es wird der <BR/>Identifikator des Kunden beim Konto gespeichert, was bedeutet, dass die Information <BR/>beim Konto für die Realisierung beider Beziehungen benutzt wird. </P><P ID="0039" ALIGN="LEFT">Zusätzlich werden im Beispiel von jedem der Basis-Komponententypen ein oder <BR/>mehrere Untertypen abgeleitet, die ebenfalls an der Beziehung teilnehmen sollen. </P><P ID="0040" ALIGN="LEFT">Als technolgisches Umfeld für die Realisierung wird ein Applikationsserver nach dem <BR/>Enterprise JavaBeans (EJB) Standard in der Version 1.1. angenommen. Alle <BR/>Komponententypen werden als Entity-Beans mit Container Managed Persistence <BR/>realisiert. Als Identifikator wird der Primary Key der jeweiligen Komponente <BR/>verwendet, über den laut EJB-Standard jedes Entity-Bean verfügen muß. Die <BR/>Konfiguration der über eine Beziehung referenzierbaren Komponenten erfolgt mit <BR/>Hilfe von EJB-References. </P><P ID="0041" ALIGN="LEFT">Die Konfiguration der Komponenten im installierten Softwaresystem zeigt Fig. 5. Bei <BR/>jeder Komponente wird für die Beziehung zum jeweils gegenüberliegenden <BR/>Vererbungsbaum ein JNDI-Kontext in der lokalen Umgebung abgelegt, der eine EJB-Referenz <BR/>für jede einzelne referenzierbare Komponente enthält. Bei der Komponente <BR/>Kunde enthält dieser JNDI-Kontext z.B. zwei Verweise, einen auf die Komponente <BR/>&quot;Konto&quot; und einen auf die Komponente &quot;GiroKonto&quot;. </P><P ID="0042" ALIGN="LEFT">Den Ablauf beim Aufbau einer Beziehung zwischen einem Konto und einem Kunden <BR/>zeigt Fig. 6. Der Vorgang wird durch einen Aufruf der Methode <I>setKunde</I> ausgelöst. <BR/>Dieser Methode wird eine Referenz auf ein Exemplar der Komponente Kunde als <BR/>Parameter übergeben. Das Konto-Exemplar fragt bei diesem Exemplar zuerst seinen <BR/>Schlüsselwert ab (<I>getPrimaryKey</I>) und speichert diesen dann in seinem persistenten <BR/>Zustand. </P><P ID="0043" ALIGN="LEFT">Den Ablauf beim Zugriff auf die Beziehung zeigt Fig. 7. Ein externer Client löst ihn <BR/>durch den Aufruf der Methode <I>getKunde</I> aus. Im ersten Schritt greift das Kunden-Exemplar <BR/>auf den lokalen JNDI-Kontext der Komponente &quot;Konto&quot; zu, in dem die EJB-Referenzen <BR/>auf die referenzierbaren Komponenten der Beziehung gespeichert sind. <BR/>Als Resultat dieses Zugriffs erhält das Komponentenexemplar eine Menge von <DP N="12"/></P><P ID="0044" ALIGN="LEFT">Referenzen auf die Verwaltungsschnittstellen dieser Komponenten. Das <BR/>Komponentenexemplar ruft jetzt nacheinander die Methode <I>findByPrimaryKey</I> auf <BR/>jeder dieser Verwaltungsschnittstellen auf und übergibt ihr als Parameter den <BR/>gespeicherten Schlüsselwert des gesuchen Kunden-Exemplars. Die Suche wird <BR/>beendet, wenn ein Exemplar gefunden wurde. Im skizzierten Anwendungsfall wird <BR/>davon ausgegangen, dass es sich bei dem gesuchten Exemplar um eine <BR/>Gemeinschaft handelt. Die Komponente &quot;Kunde&quot; kennt das gesuchte Exemplar nicht <BR/>und signalisiert das durch das Werfen einer Ausnahme vom Typ <I>NoSuchObjectException.</I> Danach ruft das Konto-Exemplar die Suchmethode auf der <BR/>Verwaltungsschnittstelle der Komponente &quot;Gemeinschaft&quot; auf. Diese Komponente <BR/>verwaltet das gesuchte Exemplar und liefert als Ergebnis der Methode eine <BR/>transiente Referenz auf das gesuchte Exemplar. Diese Referenz wird als Ergebnis <BR/>der Methode <I>getKunde</I> an den externen Client zurückgegeben. </P><P ID="0045" ALIGN="LEFT">Die Beziehung kann auch aus der Richtung der Kunden-Komponenten etabliert und <BR/>gelesen werden. Die entsprechenden Abläufe werden im Folgenden beschrieben. </P><P ID="0046" ALIGN="LEFT">Den Ablauf beim Aufbau einer Beziehung zwischen einem Kunden und einem Konto <BR/>zeigt Fig. 8. Er wird durch den Aufruf der Methode <I>addKonto</I> ausgelöst. Dieser <BR/>Methode wird vom Aufrufenden eine Referenz auf ein Kontoexemplar übergeben. Da <BR/>die persistente Speicherung der Beziehung in diesem Anwendungsbeispiel immer <BR/>auf der Seite des Kontos erfolgt, ruft der Kunde beim zu referenzierenden Konto-Exemplar <BR/>die Methode <I>setKunde</I> auf, deren Ablauf oben schon beschrieben wurde. <BR/>Damit ist die Beziehung etabliert. </P><P ID="0047" ALIGN="LEFT">Den Ablauf beim Zugriff auf die Beziehung zeigt Fig. 9. Er wird durch den Aufruf der <BR/>Methode <I>getKonten</I> auf einem Kunden-Exemplar angestoßen. Zuerst greift das <BR/>Exemplar auf den JNDI-Kontext für die Beziehung zu und erhält eine Liste mit den <BR/>Verwaltungsschnittstellen der referenzierbaren Komponenten. Nun werden mit Hilfe <BR/>der Suchmethode <I>findkontoFuerKundenSchluessel</I> auf diesen <BR/>Verwaltungsschnittstellen alle Kunden-Exemplare gesucht, die den Schlüsselwert <BR/>des suchenden Kunden-Exemplars als Fremdschlüssel in ihrem persistenten <BR/>Zustand gespeichert haben. Die Methode wird auf jeder der <BR/>Verwaltungsschnittstellen mit dem Schlüsselwert des referenzierenden Kunden-Exemplars <DP N="13"/> <BR/>aufgerufen und liefert als Ergebnis eine Menge von Referenzen auf <BR/>Konten-Exemplare. Die einzelnen Ergebnismengen werden zu einer Gesamtmenge <BR/>zusammengefasst und an den aufrufenden Client zurückgegeben. </P></SDODE>